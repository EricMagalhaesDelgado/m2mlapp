function mlappFullPath = m2mlapp(mFileFullPath, varargin)
%M2MLAPP
% M2MLAPP provides the conversion from .M to .MLAPP, enabling GitHub text
% line based control, and allowing the reconstruction of apps whose .MLAPP
% files are damaged.
%
% SYNTAX:
% mlappFullPath = m2mlapp(mFileFullPath, varargin)
%
% ARGUMENTS:
% mFileFullPath must be a scalar text (char | string) with the fullpath
% to the .M file.
%
% OPTIONAL NAME-PARAMETERS ARGUMENTS:
% - Name         scalar text (char | string) = ClassName
% - Author       scalar text (char | string) = ''
% - Version      scalar text (char | string) = '1.0'
% - Summary      scalar text (char | string) = ''
% - Description  scalar text (char | string) = 'App code generated by m2mlapp.'
% - Screenshot   logical                     = true
% - OpenApp      logical                     = true
%
% Notes:
% (a) The images referenced in the app (icon figure, uiimage, uibutton) must 
%     be in the Matlab search path during the execution of the m2mlapp function.
% (b) After validating the input arguments, the function will return the name 
%     of the .MLAPP file, or in case of a parser error, it will return an 
%     empty output.
% (c) A class loaded in the AppDesigner environment has a fixed structure, 
%     which limits customizations. In this structure, the first section is 
%     the declaration of components (according to their stacking order); 
%     then there are editable sections (properties, methods, and callbacks); 
%     and finally, the methods for creating components, and construct or 
%     delete the app.
%
% See README.md for detailed documentation and examples.

% Author.: Eric Magalh√£es Delgado
% Date...: May 24, 2023
% Version: 1.00

    arguments
        mFileFullPath {validators.mustBeScalarText}
    end

    arguments (Repeating)
        varargin
    end

    % input validation
    [mPath, mFileName, mFileExt] = fileparts(mFileFullPath);
    if isempty(mPath)
        mPath = fileparts(which(mFileFullPath));
        mFileFullPath = fullfile(mPath, [mFileName mFileExt]);
    end
    mPathFlag = util.isOnMATLABPath(mPath);

    if ~strcmp(mFileExt, '.m')
        error('The file must be .m format.')
    elseif ~isfile(mFileFullPath)
        error('The file "%s" is not located on the specified path or in a searchable folder.', mFileFullPath)
    end

    ClassName     = mFileName;
    mlappFullPath = fullfile(mPath, [ClassName '.mlapp']);


    % varargin parser
    if mod(numel(varargin), 2)
        error('Optional parameters must be in pairs.')
    end

    p = inputParser;
    d = struct('Name', ClassName, 'Author', '', 'Version', '1.0', 'Summary', '', 'Description', 'App code generated by m2mlapp.', 'Screenshot', true, 'openApp', true);

    addParameter(p, 'Name',        d.Name,        @(x) validators.mustBeScalarText(x))
    addParameter(p, 'Author',      d.Author,      @(x) validators.mustBeScalarText(x))
    addParameter(p, 'Version',     d.Version,     @(x) validators.mustBeMajorDotMinorFormatVersion(x))
    addParameter(p, 'Summary',     d.Summary,     @(x) validators.mustBeScalarText(x))
    addParameter(p, 'Description', d.Description, @(x) validators.mustBeScalarText(x))
    addParameter(p, 'Screenshot',  d.Screenshot,  @(x) islogical(x))
    addParameter(p, 'openApp',     d.openApp,     @(x) islogical(x))

    parse(p, varargin{:});

    
    % m2mlapp
    try
        % .m parser
        matlabCode = fileread(mFileFullPath);
        treeCode   = util.treeCodeGeneration(matlabCode);
        cleanCode  = util.removeNonExecutingCode(matlabCode);
    

        % Creating "mlapp data"
        [startupFcnName, inputArgs, singleton] = util.startupFcnParser(cleanCode);
        [editableSection, callbacksFcn, startupFcn] = util.treeCodeParser(matlabCode, treeCode, startupFcnName);
        uiProperties = util.uiPropertiesParser(matlabCode, treeCode);
        [uiFigure, customComponents, tempFilePath, screenshotPath] = util.DesignTimeProperties(mPath, ClassName, matlabCode, uiProperties, p.Results.Screenshot);
    

        % Serializer object
        serializer                = appdesigner.internal.serialization.MLAPPSerializer(mlappFullPath, uiFigure);
        
        serializer.ClassName      = ClassName;
        serializer.MatlabCodeText = matlabCode;
        serializer.AppTypeData    = struct();
        
        if ~isempty(editableSection);  serializer.EditableSectionCode     = editableSection;  end
        if ~isempty(callbacksFcn);     serializer.Callbacks               = callbacksFcn;     end
        if ~isempty(startupFcn);       serializer.StartupCallback         = startupFcn;       end
        if ~isempty(screenshotPath);   serializer.ScreenshotPath          = screenshotPath;   end
        if ~isempty(inputArgs);        serializer.InputParameters         = inputArgs;        end
        if ~isempty(singleton);        serializer.SingletonMode           = singleton;        end
        if ~isempty(customComponents); serializer.Metadata.UserComponents = customComponents; end

        serializer.Metadata.Name        = p.Results.Name;
        serializer.Metadata.Author      = p.Results.Author;
        serializer.Metadata.Version     = p.Results.Version;
        serializer.Metadata.Summary     = p.Results.Summary;
        serializer.Metadata.Description = p.Results.Description;
        
        serializer.save();


        % Open app
        if p.Results.openApp
            appDesignEnvironment = appdesigner.internal.application.getAppDesignEnvironment();
            appDesignEnvironment.openApp(mlappFullPath)
        end

    catch ME
        disp(getReport(ME))
        mlappFullPath = '';
    end


    % Dealing with the created mess...
    if ~mPathFlag && util.isOnMATLABPath(mPath)
        rmpath(mPath)
    end

    if exist('uiFigure', 'var')
        delete(uiFigure)
        delete(tempFilePath)
    end

end